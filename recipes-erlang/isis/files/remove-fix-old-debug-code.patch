From bb8d27761801b1950688301c791c4b977be166db Mon Sep 17 00:00:00 2001
From: Christian Franke <chris@opensourcerouting.org>
Date: Wed, 15 Oct 2014 16:51:41 +0000
Subject: [PATCH 3/3] Remove outdated debug code

---
 src/demo.erl       | 385 -----------------------------------------------------
 src/isis_debug.erl |  85 ------------
 src/lsp_feed.erl   |   2 +-
 3 files changed, 1 insertion(+), 471 deletions(-)
 delete mode 100644 src/demo.erl

diff --git a/src/demo.erl b/src/demo.erl
deleted file mode 100644
index 576eb9d..0000000
--- a/src/demo.erl
+++ /dev/null
@@ -1,385 +0,0 @@
-%%%-------------------------------------------------------------------
-%%% @author Rick Payne <rickp@rossfell.co.uk>
-%%% @copyright (C) 2014, Alistair Woodman, California USA <awoodman@netdef.org>
-%%% @doc
-%%%
-%%% Demo system, to poke some LSPs into the database and create some
-%%% churn as if we had a real network.
-%%% 
-%%% This file is part of AutoISIS.
-%%%
-%%% License:
-%%% AutoISIS can be used (at your option) under the following GPL or under
-%%% a commercial license
-%%% 
-%%% Choice 1: GPL License
-%%% AutoISIS is free software; you can redistribute it and/or modify it
-%%% under the terms of the GNU General Public License as published by the
-%%% Free Software Foundation; either version 2, or (at your option) any
-%%% later version.
-%%% 
-%%% AutoISIS is distributed in the hope that it will be useful, but
-%%% WITHOUT ANY WARRANTY; without even the implied warranty of
-%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See 
-%%% the GNU General Public License for more details.
-%%% 
-%%% You should have received a copy of the GNU General Public License
-%%% along with GNU Zebra; see the file COPYING.  If not, write to the Free
-%%% Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-%%% 02111-1307, USA.
-%%% 
-%%% Choice 2: Commercial License Usage
-%%% Licensees holding a valid commercial AutoISIS may use this file in 
-%%% accordance with the commercial license agreement provided with the 
-%%% Software or, alternatively, in accordance with the terms contained in 
-%%% a written agreement between you and the Copyright Holder.  For
-%%% licensing terms and conditions please contact us at 
-%%% licensing@netdef.org
-%%%
-%%% @end
-%%% Created :  2 Apr 2014 by Rick Payne <rickp@rossfell.co.uk>
-%%%-------------------------------------------------------------------
--module(demo).
-
--behaviour(gen_server).
-
--include("isis_system.hrl").
--include("isis_protocol.hrl").
-
-%% API
--export([start_link/0, stop/0]).
-
-%% gen_server callbacks
--export([init/1, handle_call/3, handle_cast/2, handle_info/2,
-	 terminate/2, code_change/3]).
-
--define(SERVER, ?MODULE).
-
--record(state, {
-	  timer,        %% Our timer for events
-	  nextstate,    %% Simple FSM...
-	  sequence = 1  %% Next sequence number to use in LSPs
-	 }).
-
-%%%===================================================================
-%%% API
-%%%===================================================================
-stop() ->
-    gen_server:call(?MODULE, stop).
-
-%%--------------------------------------------------------------------
-%% @doc
-%% Starts the server
-%%
-%% @spec start_link() -> {ok, Pid} | ignore | {error, Error}
-%% @end
-%%--------------------------------------------------------------------
-start_link() ->
-    gen_server:start_link({local, ?SERVER}, ?MODULE, [], []).
-
-%%%===================================================================
-%%% gen_server callbacks
-%%%===================================================================
-
-%%--------------------------------------------------------------------
-%% @private
-%% @doc
-%% Initializes the server
-%%
-%% @spec init(Args) -> {ok, State} |
-%%                     {ok, State, Timeout} |
-%%                     ignore |
-%%                     {stop, Reason}
-%% @end
-%%--------------------------------------------------------------------
-init([]) ->
-    Timer = erlang:start_timer(isis_protocol:jitter(20 * 1000, 50),
-			       self(), ping),
-    State = create_initial_state(),
-    {ok, State#state{timer = Timer}}.
-
-%%--------------------------------------------------------------------
-%% @private
-%% @doc
-%% Handling call messages
-%%
-%% @spec handle_call(Request, From, State) ->
-%%                                   {reply, Reply, State} |
-%%                                   {reply, Reply, State, Timeout} |
-%%                                   {noreply, State} |
-%%                                   {noreply, State, Timeout} |
-%%                                   {stop, Reason, Reply, State} |
-%%                                   {stop, Reason, State}
-%% @end
-%%--------------------------------------------------------------------
-handle_call(stop, _From, State) ->
-    {stop, normal, State};
-handle_call(_Request, _From, State) ->
-    Reply = ok,
-    {reply, Reply, State}.
-
-%%--------------------------------------------------------------------
-%% @private
-%% @doc
-%% Handling cast messages
-%%
-%% @spec handle_cast(Msg, State) -> {noreply, State} |
-%%                                  {noreply, State, Timeout} |
-%%                                  {stop, Reason, State}
-%% @end
-%%--------------------------------------------------------------------
-handle_cast(_Msg, State) ->
-    {noreply, State}.
-
-%%--------------------------------------------------------------------
-%% @private
-%% @doc
-%% Handling all non call/cast messages
-%%
-%% @spec handle_info(Info, State) -> {noreply, State} |
-%%                                   {noreply, State, Timeout} |
-%%                                   {stop, Reason, State}
-%% @end
-%%--------------------------------------------------------------------
-handle_info({timeout, _Ref, ping}, State) ->
-    NewState = next_demo(State),
-    Timer = erlang:start_timer(isis_protocol:jitter(20 * 1000, 50),
-			       self(), ping),
-    {noreply, NewState#state{timer = Timer}};
-handle_info(_Info, State) ->
-    {noreply, State}.
-
-%%--------------------------------------------------------------------
-%% @private
-%% @doc
-%% This function is called by a gen_server when it is about to
-%% terminate. It should be the opposite of Module:init/1 and do any
-%% necessary cleaning up. When it returns, the gen_server terminates
-%% with Reason. The return value is ignored.
-%%
-%% @spec terminate(Reason, State) -> void()
-%% @end
-%%--------------------------------------------------------------------
-terminate(_Reason, _State) ->
-    ok.
-
-%%--------------------------------------------------------------------
-%% @private
-%% @doc
-%% Convert process state when code is changed
-%%
-%% @spec code_change(OldVsn, State, Extra) -> {ok, NewState}
-%% @end
-%%--------------------------------------------------------------------
-code_change(_OldVsn, State, _Extra) ->
-    {ok, State}.
-
-%%%===================================================================
-%%% Internal functions
-%%%===================================================================
-create_initial_state() ->
-    #state{nextstate = setup}.
-
-next_demo(#state{nextstate = setup} = State) ->
-    %% Create our 2 'gateway' nodes and cosy up to them...
-    isis_system:add_sid_addresses(<<16#de, 16#ad, 16#be, 16#ef, 0, 0>>,
-				  [{ipv4, 55664433}]),
-    isis_system:add_sid_addresses(<<16#c0, 16#ff, 16#fe, 0, 0, 0>>,
-				  [{ipv4, 99887766}]),
-    isis_system:add_sid_addresses(<<16#de, 16#ad, 16#be, 16#ef, 0, 0>>,
-				  [{ipv6, <<1,2,3,4, 0:(8*12)>>}]),
-    isis_system:add_sid_addresses(<<16#c0, 16#ff, 16#fe, 0, 0, 0>>,
-				  [{ipv6, <<4,3,2,1, 0:(8*12)>>}]),
-    DeadBeefTLV = #isis_tlv_extended_reachability{
-		     reachability = [#isis_tlv_extended_reachability_detail{
-					neighbor = <<16#de, 16#ad, 16#be, 16#ef, 0, 0, 0>>,
-					metric = 1500, sub_tlv=[]}]},
-    CoffeeTLV = #isis_tlv_extended_reachability{
-		   reachability = [#isis_tlv_extended_reachability_detail{
-				      neighbor = <<16#c0, 16#ff, 16#fe, 0, 0, 0, 0>>,
-				      metric = 15000, sub_tlv=[]}]},
-    isis_system:update_tlv(DeadBeefTLV, 0, level_1),
-    isis_system:update_tlv(CoffeeTLV, 0, level_1),
-    %% Now we stir up some LSPs
-    NextState = generate_lsps(State),
-    NextState#state{nextstate = running};
-next_demo(#state{nextstate = running} = State) ->
-    generate_lsps(State);
-next_demo(_) ->
-    stop.
-
-generate_lsps(State) ->
-    L = random_list(8),
-    CoffeeNodes = lists:sublist(L, 1, 3),
-    DeadBeefNodes = lists:sublist(L, 4, 3),
-    TopNodes = lists:sublist(L, 7, 2),
-    generate_coffee(CoffeeNodes, <<16#c0, 16#ff, 16#fe, 0, 0, 0>>,
-		    lists:nth(1, TopNodes), State),
-    generate_coffee(DeadBeefNodes, <<16#de, 16#ad, 16#be, 16#ef, 0, 0>>,
-		    lists:nth(2, TopNodes), State),
-    State#state{sequence = State#state.sequence + 1}.
-
-
-generate_coffee(Nodes, Link, TN, State) ->
-    Creator = 
-	fun(N, Acc) ->
-		NeighborID = <<N:16, 0, 0, 0, 0, 0>>,
-		LSPID = <<NeighborID/binary, 0>>,
-		Hostname = string:concat("injected-", integer_to_list(N)),
-		PrefixBin = <<1:8, N:8, 0:16>>,
-		<<Prefix:32>> = PrefixBin,
-		{ReachabilityTLV, NewAcc} = 
-		    case random:uniform() > 0.5 of
-			true ->
-			    {#isis_tlv_extended_reachability{
-				reachability = [#isis_tlv_extended_reachability_detail{
-						   neighbor = <<Link:6/binary, 0:8>>,
-						   metric = erlang:trunc(random:uniform() * 1000),
-						   sub_tlv = []},
-						#isis_tlv_extended_reachability_detail{
-						   neighbor = <<TN:16, 0, 0, 0, 0, 0>>,
-						   metric = erlang:trunc(random:uniform() * 1000),
-						   sub_tlv = []
-						  }
-					       ]},
-			     Acc ++ [N]};
-			_ ->
-			    {#isis_tlv_extended_reachability{
-				reachability = [#isis_tlv_extended_reachability_detail{
-						   neighbor = <<Link:6/binary, 0:8>>,
-						   metric = erlang:trunc(random:uniform() * 1000),
-						   sub_tlv = []}]},
-			     Acc}
-		    end,
-		L = #isis_lsp{
-		       lsp_id = LSPID,
-		       last_update = isis_protocol:current_timestamp(),
-		       pdu_type = level1_lsp,
-		       remaining_lifetime = 500,
-		       sequence_number = State#state.sequence,
-		       partition = false,
-		       overload = false,
-		       isis_type = level_1_2,
-		       tlv = [#isis_tlv_area_address{areas = isis_system:areas()},
-			      #isis_tlv_protocols_supported{protocols = [ipv4]},
-			      #isis_tlv_dynamic_hostname{hostname = Hostname},
-			      ReachabilityTLV,
-			      #isis_tlv_extended_ip_reachability{
-				 reachability = [#isis_tlv_extended_ip_reachability_detail{
-						    prefix = Prefix,
-						    mask_len = 24,
-						    metric = 1,
-						    up = true,
-						    sub_tlv = []}]}
-			     ]
-		      },
-		CSum = isis_protocol:checksum(L),
-		{L#isis_lsp{checksum = CSum}, NewAcc}
-	end,
-    {LSPs, TNLinks} = lists:mapfoldl(Creator, [], Nodes),
-
-    %% Now create the 'top' LSP to link to the ones that have randomly connected to us..
-    LSPs2 =
-	case length(TNLinks) > 0 of
-	    true ->
-		NNeighborID = <<TN:16, 0, 0, 0, 0, 0>>,
-		NLSPID = <<NNeighborID/binary, 0>>,
-		NHostname = string:concat("topnode-", integer_to_list(TN)),
-		NPrefixBin = <<1:8, TN:8, 0:16>>,
-		<<NPrefix:32>> = NPrefixBin,
-		NReachabilityTLV = 
-		    #isis_tlv_extended_reachability{
-		       reachability = 
-			   lists:map(fun(TNN) ->
-					     #isis_tlv_extended_reachability_detail{
-						neighbor = <<TNN:16, 0, 0, 0, 0, 0>>,
-						metric = erlang:trunc(random:uniform() * 1000),
-						sub_tlv = []}
-				     end, TNLinks)
-		      },
-		NL = #isis_lsp{
-			lsp_id = NLSPID,
-			last_update = isis_protocol:current_timestamp(),
-			pdu_type = level1_lsp,
-			remaining_lifetime = 500,
-			sequence_number = State#state.sequence,
-			partition = false,
-			overload = false,
-			isis_type = level_1_2,
-			tlv = [#isis_tlv_area_address{areas = isis_system:areas()},
-			       #isis_tlv_protocols_supported{protocols = [ipv4]},
-			       #isis_tlv_dynamic_hostname{hostname = NHostname},
-			       NReachabilityTLV,
-			       #isis_tlv_extended_ip_reachability{
-				  reachability = [#isis_tlv_extended_ip_reachability_detail{
-						     prefix = NPrefix,
-						     mask_len = 24,
-						     metric = 1,
-						     up = true,
-						     sub_tlv = []}]},
-			       #isis_tlv_ipv6_reachability{
-				  reachability = [
-						  #isis_tlv_ipv6_reachability_detail{
-						     prefix = <<16#3F, 16#FE, TN:16>>,
-						     mask_len = 32,
-						     metric = 1,
-						     up = true, external = true,
-						     sub_tlv = [
-								#isis_subtlv_srcdst{
-								   prefix_length = 16,
-								   prefix = <<1:8, TN:8>>}
-							       ]
-						    }]
-				 }
-			      ]
-		       },
-		NCSum = isis_protocol:checksum(NL),
-		[NL#isis_lsp{checksum = NCSum}] ++ LSPs;
-	    false ->
-		LSPs
-	end,
-    
-    %% Now create the coffee/deadbeef node
-    CDLSPID = <<Link:6/binary, 0, 0>>,
-    CDHostname = case Link of
-		     <<16#c0, 16#ff, 16#fe, 0, 0, 0>> -> "coffee";
-		     _ -> "deadbeef"
-		 end,
-    CDReachabilityTLV = 
-	#isis_tlv_extended_reachability{
-	   reachability = 
-	       lists:map(fun(N) ->
-				 #isis_tlv_extended_reachability_detail{
-				    neighbor = <<N:16, 0, 0, 0, 0, 0>>,
-				    metric = erlang:trunc(random:uniform() * 1000),
-				    sub_tlv = []}
-			 end, Nodes)
-	   ++ [#isis_tlv_extended_reachability_detail{
-		  neighbor = <<(isis_system:system_id()):6/binary, 0>>,
-		  metric = erlang:trunc(random:uniform() * 1000),
-		  sub_tlv = []}]
-	  },
-    CDL = #isis_lsp{
-	     lsp_id = CDLSPID,
-	     last_update = isis_protocol:current_timestamp(),
-	     pdu_type = level1_lsp,
-	     remaining_lifetime = 500,
-	     sequence_number = State#state.sequence,
-	     partition = false,
-	     overload = false,
-	     isis_type = level_1_2,
-	     tlv = [#isis_tlv_area_address{areas = isis_system:areas()},
-		    #isis_tlv_protocols_supported{protocols = [ipv4]},
-		    #isis_tlv_dynamic_hostname{hostname = CDHostname},
-		    CDReachabilityTLV
-		   ]
-	    },
-    CDSum = isis_protocol:checksum(CDL),
-    CDLsp = CDL#isis_lsp{checksum = CDSum},
-    LA = [CDLsp] ++ LSPs2,
-    lists:map(fun(L) -> isis_lspdb:store_lsp(level_1, L) end,
-	      LA).
-	
-random_list(Count) ->
-     L = lists:seq(1,Count),
-    [X||{_,X} <- lists:sort([ {random:uniform(), N} || N <- L])].
diff --git a/src/isis_debug.erl b/src/isis_debug.erl
index 9945974..f1ef229 100644
--- a/src/isis_debug.erl
+++ b/src/isis_debug.erl
@@ -129,91 +129,6 @@ valid_csnp() ->
 invalid_lsp() ->
     ?TEST_INVALID_LSP.
 
-%% Generate a chunk of LSPs into our LSPDB to test things So we create
-%% a list of 'Count' numbers, and then turn each one into an LSP that
-%% has 'reachability' to the previous and next LSP. ie. a long chain.
-%% We give them a hostname as well. Then we inject into the Database..
-inject_some_lsps(Level, Count, Seq)
-  when Count < 50 ->
-    isis_system:add_sid_addresses(<<1:16, 0, 0, 0, 0>>,  [{ipv4, 3232298895}]),
-    Numbers = lists:seq(1, Count),
-    PDU = case Level of
-	      level_1 -> level1_lsp;
-	      _ -> level2_lsp
-	  end,
-    Creator = 
-	fun(N, Acc) ->
-		NeighborID = <<N:16, 0, 0, 0, 0, 0>>,
-		NextNeighborID = <<(N+1):16, 0, 0, 0, 0, 0>>,
-		LSPID = <<NeighborID/binary, 0>>,
-		Hostname = string:concat("injected", integer_to_list(N)),
-		PrefixBin = <<1:8, N:8, 0:16>>,
-		<<Prefix:32>> = PrefixBin,
-		L = #isis_lsp{
-		       lsp_id = LSPID,
-		       last_update = isis_protocol:current_timestamp(),
-		       pdu_type = PDU,
-		       remaining_lifetime = 500,
-		       sequence_number = Seq,
-		       partition = false,
-		       overload = false,
-		       isis_type = level_1_2,
-		       tlv = [#isis_tlv_area_address{areas = isis_system:areas()},
-			      #isis_tlv_protocols_supported{protocols = [ipv4]},
-			      #isis_tlv_dynamic_hostname{hostname = Hostname},
-			      #isis_tlv_extended_reachability{
-				 reachability = [#isis_tlv_extended_reachability_detail{
-						    neighbor = Acc,
-						    metric = N,
-						    sub_tlv = []},
-						#isis_tlv_extended_reachability_detail{
-						   neighbor = NextNeighborID,
-						   metric = N,
-						   sub_tlv = []
-						  }
-						]},
-			      #isis_tlv_extended_ip_reachability{
-				 reachability = [#isis_tlv_extended_ip_reachability_detail{
-						    prefix = Prefix,
-						    mask_len = 24,
-						    metric = 1,
-						    up = true,
-						    sub_tlv = []}]},
-			      #isis_tlv_unknown{type = 99, bytes = <<1,2,3,4,5,6,7,8,9,10>>}
-			     ]
-		      },
-		CSum = isis_protocol:checksum(L),
-		%% isis_lspdb:store(level_2, L#isis_lsp{checksum = CSum}),
-		{L#isis_lsp{checksum = CSum}, NeighborID}
-	end,
-    Start = <<(isis_system:system_id()):6/binary, 0>>,
-    {LSPs, _} = lists:mapfoldl(Creator, Start, Numbers),
-    %% Now inject into the database
-    Injector = 	fun(L) -> isis_lspdb:store_lsp(Level, L) end,
-    lists:map(Injector, LSPs),
-    ChainTLV = #isis_tlv_extended_reachability{
-		  reachability = [#isis_tlv_extended_reachability_detail{
-				     neighbor = <<1:16, 0, 0, 0, 0, 0>>,
-				     metric = 16819, sub_tlv=[]}]},
-    isis_system:update_tlv(ChainTLV, 0, Level),
-    ok;
-inject_some_lsps(_, _, _) ->
-    error.
-
-
-purge_injected_lsps(Level, Count) ->
-    IDCreator = fun(N) -> <<N:16, 0, 0, 0, 0, 0, 0>> end,
-    LSPIDs = lists:map(IDCreator, lists:seq(1, Count)),
-    Purge = fun(LSPID) -> isis_system:purge_lsp(Level, LSPID) end,
-    lists:map(Purge, LSPIDs),
-    ChainTLV = #isis_tlv_extended_reachability{
-		  reachability = [#isis_tlv_extended_reachability_detail{
-				     neighbor = <<1:16, 0, 0, 0, 0, 0>>,
-				     metric = 10, sub_tlv=[]}]},
-    isis_system:delete_tlv(ChainTLV, 0, Level),
-    isis_system:delete_sid_addresses(<<1:16, 0, 0, 0, 0>>, [{ipv4, 3232298895}]),
-    ok.
-
 %%%===================================================================
 %%% Internal functions
 %%%===================================================================
diff --git a/src/lsp_feed.erl b/src/lsp_feed.erl
index 0ff811c..36b86d2 100644
--- a/src/lsp_feed.erl
+++ b/src/lsp_feed.erl
@@ -76,7 +76,7 @@ handle_message({text, <<"start level_1">>}, State) ->
     {noreply, State#state{level = level_1}};
 
 handle_message({text, <<"start level_2">>}, State) ->
-    lspdb:subscribe(level_2, self()),
+    isis_lspdb:subscribe(level_2, self()),
     {reply, {text, <<"buh">>}, State#state{level = level_2}};
 
 handle_message({close, Status, _Reason}, State) ->
-- 
1.9.1

