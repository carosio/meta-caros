From 4cb6450535cbfd1bf4f9ea7ac3ceabe4eafef6f1 Mon Sep 17 00:00:00 2001
From: GalaxyGorilla <skattelmann@gmail.com>
Date: Mon, 19 Oct 2015 11:32:43 +0200
Subject: [PATCH] Added feature to alter the appearance of the log line called
 by journalctl.

The relevant option is the '-o' flag which can be called with a formatter
string, e.g.

    journalctl -o "format:{__REALTIME_TIMESTAMP:date} {MESSAGE:60}"

which will output the date (a formatted Unix timestamp) and the message
(truncated to 60 characters). Literals are also allowed outside of the curly
braces. There are only the mentioned two options - date formatting and
string truncating - available. Those cannot be mixed.

The possible date formats are

    - date              Okt 20 10:22:05
    - date-iso          2015-10-20T10:22:05+0200
    - date-precise      Okt 20 10:22:05.056146
    - date-raw          [1445329325.056146]

where 'date' is the default on "__REALTIME_TIMESTAMP".
---
 src/journal-remote/journal-gatewayd.c |   8 +-
 src/journal/journalctl.c              |  38 +--
 src/login/loginctl.c                  |  22 +-
 src/machine/machinectl.c              |  19 +-
 src/shared/logs-show.c                | 449 +++++++++++++++++++++++++++++-----
 src/shared/logs-show.h                |  14 +-
 src/shared/output-mode.h              |   1 +
 src/systemctl/systemctl.c             |  20 +-
 8 files changed, 471 insertions(+), 100 deletions(-)

Index: git/src/journal-remote/journal-gatewayd.c
===================================================================
--- git.orig/src/journal-remote/journal-gatewayd.c	2015-11-14 23:11:22.859799467 +0000
+++ git/src/journal-remote/journal-gatewayd.c	2015-11-14 23:11:22.847799467 +0000
@@ -150,6 +150,7 @@
         RequestMeta *m = cls;
         int r;
         size_t n, k;
+        _cleanup_output_formatter_ OutputFormatter *output_formatter = NULL;
 
         assert(m);
         assert(buf);
@@ -158,6 +159,11 @@
 
         pos -= m->delta;
 
+        if ((r = output_formatter_from_mode(m->mode, &output_formatter)) < 0) {
+                log_error("Failed to parse mode: %s", strerror(-r));
+                return MHD_CONTENT_READER_END_WITH_ERROR;
+        }
+
         while (pos >= m->size) {
                 off_t sz;
 
@@ -220,7 +226,7 @@
                         return MHD_CONTENT_READER_END_WITH_ERROR;
                 }
 
-                r = output_journal(m->tmp, m->journal, m->mode, 0, OUTPUT_FULL_WIDTH, NULL);
+                r = output_journal(m->tmp, m->journal, output_formatter, 0, OUTPUT_FULL_WIDTH, NULL);
                 if (r < 0) {
                         log_error_errno(r, "Failed to serialize item: %m");
                         return MHD_CONTENT_READER_END_WITH_ERROR;
Index: git/src/journal/journalctl.c
===================================================================
--- git.orig/src/journal/journalctl.c	2015-11-14 23:11:22.859799467 +0000
+++ git/src/journal/journalctl.c	2015-11-14 23:11:22.851799467 +0000
@@ -70,7 +70,8 @@
         ARG_LINES_ALL = -1,
 };
 
-static OutputMode arg_output = OUTPUT_SHORT;
+static const char *arg_output = "short";
+static OutputFormatter *arg_formatter = NULL;
 static bool arg_utc = false;
 static bool arg_pager_end = false;
 static bool arg_follow = false;
@@ -212,7 +213,8 @@
                "  -r --reverse             Show the newest entries first\n"
                "  -o --output=STRING       Change journal output mode (short, short-iso,\n"
                "                                   short-precise, short-monotonic, verbose,\n"
-               "                                   export, json, json-pretty, json-sse, cat)\n"
+               "                                   export, json, json-pretty, json-sse, cat,\n"
+               "                                   format:FORMAT-STRING)\n"
                "     --utc                 Express time in Coordinated Universal Time (UTC)\n"
                "  -x --catalog             Add message explanations where available\n"
                "     --no-full             Ellipsize fields\n"
@@ -337,6 +339,8 @@
         };
 
         int c, r;
+        int err;
+        OutputMode mode;
 
         assert(argc >= 0);
         assert(argv);
@@ -371,19 +375,7 @@
                         break;
 
                 case 'o':
-                        arg_output = output_mode_from_string(optarg);
-                        if (arg_output < 0) {
-                                log_error("Unknown output format '%s'.", optarg);
-                                return -EINVAL;
-                        }
-
-                        if (arg_output == OUTPUT_EXPORT ||
-                            arg_output == OUTPUT_JSON ||
-                            arg_output == OUTPUT_JSON_PRETTY ||
-                            arg_output == OUTPUT_JSON_SSE ||
-                            arg_output == OUTPUT_CAT)
-                                arg_quiet = true;
-
+                        arg_output = optarg;
                         break;
 
                 case 'l':
@@ -706,6 +698,20 @@
                         assert_not_reached("Unhandled option");
                 }
 
+        if ((err = output_formatter_from_string(arg_output,
+                &arg_formatter)) < 0) {
+                log_error("Unknown/malformed output format '%s'.", arg_output);
+                return err;
+        }
+
+        mode = output_formatter_get_mode(arg_formatter);
+        if (mode == OUTPUT_EXPORT ||
+            mode == OUTPUT_JSON ||
+            mode == OUTPUT_JSON_PRETTY ||
+            mode == OUTPUT_JSON_SSE ||
+            mode == OUTPUT_CAT)
+                arg_quiet = true;
+
         if (arg_follow && !arg_no_tail && !arg_since && arg_lines == ARG_LINES_DEFAULT)
                 arg_lines = 10;
 
@@ -2161,7 +2167,7 @@
                                 arg_catalog * OUTPUT_CATALOG |
                                 arg_utc * OUTPUT_UTC;
 
-                        r = output_journal(stdout, j, arg_output, 0, flags, &ellipsized);
+                        r = output_journal(stdout, j, arg_formatter, 0, flags, &ellipsized);
                         need_seek = true;
                         if (r == -EADDRNOTAVAIL)
                                 break;
Index: git/src/login/loginctl.c
===================================================================
--- git.orig/src/login/loginctl.c	2015-11-14 23:11:22.859799467 +0000
+++ git/src/login/loginctl.c	2015-11-14 23:11:22.851799467 +0000
@@ -56,7 +56,8 @@
 static char *arg_host = NULL;
 static bool arg_ask_password = true;
 static unsigned arg_lines = 10;
-static OutputMode arg_output = OUTPUT_SHORT;
+static const char *arg_output = "short";
+static OutputFormatter *arg_formatter = NULL;
 
 static void pager_open_if_enabled(void) {
 
@@ -538,7 +539,7 @@
                         show_journal_by_unit(
                                         stdout,
                                         i.scope,
-                                        arg_output,
+                                        arg_formatter,
                                         0,
                                         i.timestamp.monotonic,
                                         arg_lines,
@@ -618,7 +619,7 @@
                 show_journal_by_unit(
                                 stdout,
                                 i.slice,
-                                arg_output,
+                                arg_formatter,
                                 0,
                                 i.timestamp.monotonic,
                                 arg_lines,
@@ -1196,7 +1197,8 @@
                "  -s --signal=SIGNAL       Which signal to send\n"
                "  -n --lines=INTEGER       Number of journal entries to show\n"
                "  -o --output=STRING       Change journal output mode (short, short-monotonic,\n"
-               "                           verbose, export, json, json-pretty, json-sse, cat)\n\n"
+               "                           verbose, export, json, json-pretty, json-sse, cat,\n\n"
+               "                           format:FORMAT-STRING)\n"
                "Session Commands:\n"
                "  list-sessions            List sessions\n"
                "  session-status [ID...]   Show session status\n"
@@ -1257,6 +1259,7 @@
         };
 
         int c, r;
+        int err;
 
         assert(argc >= 0);
         assert(argv);
@@ -1302,11 +1305,7 @@
                         break;
 
                 case 'o':
-                        arg_output = output_mode_from_string(optarg);
-                        if (arg_output < 0) {
-                                log_error("Unknown output '%s'.", optarg);
-                                return -EINVAL;
-                        }
+                        arg_output = optarg;
                         break;
 
                 case ARG_NO_PAGER:
@@ -1350,6 +1349,11 @@
                         assert_not_reached("Unhandled option");
                 }
 
+        if ((err = output_formatter_from_string(arg_output, &arg_formatter)) < 0) {
+                log_error("Unknown / malformed output format '%s'.", arg_output);
+                return err;
+        }
+
         return 1;
 }
 
Index: git/src/machine/machinectl.c
===================================================================
--- git.orig/src/machine/machinectl.c	2015-11-14 23:11:22.859799467 +0000
+++ git/src/machine/machinectl.c	2015-11-14 23:11:22.851799467 +0000
@@ -72,7 +72,8 @@
 static bool arg_quiet = false;
 static bool arg_ask_password = true;
 static unsigned arg_lines = 10;
-static OutputMode arg_output = OUTPUT_SHORT;
+static const char *arg_output = "short";
+static OutputFormatter *arg_formatter = NULL;
 static bool arg_force = false;
 static ImportVerify arg_verify = IMPORT_VERIFY_SIGNATURE;
 static const char* arg_dkr_index_url = NULL;
@@ -603,7 +604,7 @@
                         show_journal_by_unit(
                                         stdout,
                                         i->unit,
-                                        arg_output,
+                                        arg_formatter,
                                         0,
                                         i->timestamp.monotonic,
                                         arg_lines,
@@ -2453,7 +2454,7 @@
                "  -n --lines=INTEGER          Number of journal entries to show\n"
                "  -o --output=STRING          Change journal output mode (short,\n"
                "                              short-monotonic, verbose, export, json,\n"
-               "                              json-pretty, json-sse, cat)\n"
+               "                              json-pretty, json-sse, cat, format:FORMAT-STRING)\n"
                "      --verify=MODE           Verification mode for downloaded images (no,\n"
                "                              checksum, signature)\n"
                "      --force                 Download image even if already exists\n"
@@ -2548,6 +2549,7 @@
         };
 
         int c, r;
+        int err;
 
         assert(argc >= 0);
         assert(argv);
@@ -2591,11 +2593,7 @@
                         break;
 
                 case 'o':
-                        arg_output = output_mode_from_string(optarg);
-                        if (arg_output < 0) {
-                                log_error("Unknown output '%s'.", optarg);
-                                return -EINVAL;
-                        }
+                        arg_output = optarg;
                         break;
 
                 case ARG_NO_PAGER:
@@ -2696,6 +2694,11 @@
                         assert_not_reached("Unhandled option");
                 }
 
+        if ((err = output_formatter_from_string(arg_output, &arg_formatter)) < 0) {
+                log_error("Unknown / malformed output format '%s'.", arg_output);
+                return err;
+        }
+
         return 1;
 }
 
Index: git/src/shared/logs-show.c
===================================================================
--- git.orig/src/shared/logs-show.c	2015-11-14 23:11:22.859799467 +0000
+++ git/src/shared/logs-show.c	2015-11-14 23:11:22.851799467 +0000
@@ -43,6 +43,35 @@
 
 #define JSON_THRESHOLD 4096
 
+typedef int (*OutputFunc)(OutputFormatter *formatter,
+                          FILE *f,
+                          sd_journal*j,
+                          unsigned n_columns,
+                          OutputFlags flags);
+
+typedef enum {
+        OUTPUT_FIELD_LITERAL,      /* data is a literal string to print */
+        OUTPUT_FIELD_DATE,         /* data is a variable to show as a simple date */
+        OUTPUT_FIELD_DATE_PRECISE, /* data is a variable to show as a precise date */
+        OUTPUT_FIELD_DATE_ISO,     /* data is a variable to show as a ISO date */
+        OUTPUT_FIELD_DATE_RAW,     /* data is a variable to show as a RAW timestamp */
+        OUTPUT_FIELD_RAW,          /* data is a variable to show as a raw string */
+} OutputFieldType;
+
+typedef struct _OutputField {
+        OutputFieldType type;
+        size_t vallen; /* Truncate value to this length when printing */
+        const char *data;
+        size_t datalen;
+} OutputField;
+
+struct _OutputFormatter {
+        OutputFunc handler;
+        OutputMode mode;
+        size_t nfields;
+        OutputField *fields;
+};
+
 static int print_catalog(FILE *f, sd_journal *j) {
         int r;
         _cleanup_free_ char *t = NULL, *z = NULL;
@@ -190,10 +219,57 @@
         return ellipsized;
 }
 
+static int print_time(uint64_t ts, OutputFieldType type, FILE *f) {
+        int n, r;
+        char buf[64];
+        time_t t;
+        struct tm tm;
+
+        assert(f);
+
+        t = (time_t)(ts / USEC_PER_SEC);
+
+        switch (type) {
+        case OUTPUT_FIELD_DATE:
+                r = strftime(buf, sizeof(buf), "%b %d %H:%M:%S", localtime_r(&t, &tm));
+                break;
+
+        case OUTPUT_FIELD_DATE_PRECISE:
+                r = strftime(buf, sizeof(buf), "%b %d %H:%M:%S", localtime_r(&t, &tm));
+                if (r > 0) {
+                        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
+                                 ".%06llu", (unsigned long long) (ts % USEC_PER_SEC));
+                }
+                break;
+
+        case OUTPUT_FIELD_DATE_ISO:
+                r = strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S%z", localtime_r(&t, &tm));
+                break;
+
+        case OUTPUT_FIELD_DATE_RAW:
+                r = snprintf(buf, sizeof(buf), "[%5llu.%06llu]",
+                             (unsigned long long) (ts / USEC_PER_SEC),
+                             (unsigned long long) (ts % USEC_PER_SEC));
+                break;
+
+        default:
+                return -EINVAL;
+        }
+
+        if (r <= 0) {
+                log_error("Failed to format time.");
+                return -EINVAL;
+        }
+        fputs(buf, f);
+        n = strlen(buf);
+
+        return n;
+}
+
 static int output_short(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -206,6 +282,7 @@
         int p = LOG_INFO;
         bool ellipsized = false;
 
+        assert(formatter);
         assert(f);
         assert(j);
 
@@ -286,7 +363,7 @@
         if (priority_len == 1 && *priority >= '0' && *priority <= '7')
                 p = *priority - '0';
 
-        if (mode == OUTPUT_SHORT_MONOTONIC) {
+        if (formatter->mode == OUTPUT_SHORT_MONOTONIC) {
                 uint64_t t;
                 sd_id128_t boot_id;
 
@@ -301,21 +378,15 @@
                 if (r < 0)
                         return log_error_errno(r, "Failed to get monotonic timestamp: %m");
 
-                fprintf(f, "[%5llu.%06llu]",
-                        (unsigned long long) (t / USEC_PER_SEC),
-                        (unsigned long long) (t % USEC_PER_SEC));
+                if ((r = print_time(t, OUTPUT_FIELD_DATE_RAW, f)) < 0)
+                        return log_error_errno(r, "Failed to format monotonic timestamp: %m");
 
-                n += 1 + 5 + 1 + 6 + 1;
+                n += r;
 
         } else {
-                char buf[64];
                 uint64_t x;
-                time_t t;
-                struct tm tm;
-                struct tm *(*gettime_r)(const time_t *, struct tm *);
 
                 r = -ENOENT;
-                gettime_r = (flags & OUTPUT_UTC) ? gmtime_r : localtime_r;
 
                 if (realtime)
                         r = safe_atou64(realtime, &x);
@@ -326,30 +397,21 @@
                 if (r < 0)
                         return log_error_errno(r, "Failed to get realtime timestamp: %m");
 
-                t = (time_t) (x / USEC_PER_SEC);
-
-                switch(mode) {
+                switch (formatter->mode) {
                 case OUTPUT_SHORT_ISO:
-                        r = strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S%z", gettime_r(&t, &tm));
+                        if ((r = print_time(x, OUTPUT_FIELD_DATE_ISO, f)) < 0)
+                                return log_error_errno(r, "Failed to format time as iso timestamp: %m");
                         break;
                 case OUTPUT_SHORT_PRECISE:
-                        r = strftime(buf, sizeof(buf), "%b %d %H:%M:%S", gettime_r(&t, &tm));
-                        if (r > 0) {
-                                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
-                                         ".%06llu", (unsigned long long) (x % USEC_PER_SEC));
-                        }
+                        if ((r = print_time(x, OUTPUT_FIELD_DATE_PRECISE, f)) < 0)
+                                return log_error_errno(r, "Failed to format time as precise timestamp: %m");
                         break;
                 default:
-                        r = strftime(buf, sizeof(buf), "%b %d %H:%M:%S", gettime_r(&t, &tm));
-                }
-
-                if (r <= 0) {
-                        log_error("Failed to format time.");
-                        return -EINVAL;
+                        if ((r = print_time(x, OUTPUT_FIELD_DATE, f)) < 0)
+                                return log_error_errno(r, "Failed to format time as default timestamp: %m");
+                        break;
                 }
-
-                fputs(buf, f);
-                n += strlen(buf);
+                n += r;
         }
 
         if (hostname && shall_print(hostname, hostname_len, flags)) {
@@ -390,9 +452,9 @@
 }
 
 static int output_verbose(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -403,6 +465,7 @@
         char ts[FORMAT_TIMESTAMP_MAX + 7];
         int r;
 
+        assert(formatter);
         assert(f);
         assert(j);
 
@@ -488,9 +551,9 @@
 }
 
 static int output_export(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -502,6 +565,7 @@
         const void *data;
         size_t length;
 
+        assert(formatter);
         assert(j);
 
         sd_journal_set_data_threshold(j, 0);
@@ -619,9 +683,9 @@
 }
 
 static int output_json(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -635,6 +699,7 @@
         Hashmap *h = NULL;
         bool done, separator;
 
+        assert(formatter);
         assert(j);
 
         sd_journal_set_data_threshold(j, flags & OUTPUT_SHOW_ALL ? 0 : JSON_THRESHOLD);
@@ -651,7 +716,7 @@
         if (r < 0)
                 return log_error_errno(r, "Failed to get cursor: %m");
 
-        if (mode == OUTPUT_JSON_PRETTY)
+        if (formatter->mode == OUTPUT_JSON_PRETTY)
                 fprintf(f,
                         "{\n"
                         "\t\"__CURSOR\" : \"%s\",\n"
@@ -663,7 +728,7 @@
                         monotonic,
                         sd_id128_to_string(boot_id, sid));
         else {
-                if (mode == OUTPUT_JSON_SSE)
+                if (formatter->mode == OUTPUT_JSON_SSE)
                         fputs("data: ", f);
 
                 fprintf(f,
@@ -743,7 +808,7 @@
                                 continue;
 
                         if (separator) {
-                                if (mode == OUTPUT_JSON_PRETTY)
+                                if (formatter->mode == OUTPUT_JSON_PRETTY)
                                         fputs(",\n\t", f);
                                 else
                                         fputs(", ", f);
@@ -818,9 +883,9 @@
 
         } while (!done);
 
-        if (mode == OUTPUT_JSON_PRETTY)
+        if (formatter->mode == OUTPUT_JSON_PRETTY)
                 fputs("\n}\n", f);
-        else if (mode == OUTPUT_JSON_SSE)
+        else if (formatter->mode == OUTPUT_JSON_SSE)
                 fputs("}\n\n", f);
         else
                 fputs(" }\n", f);
@@ -837,9 +902,9 @@
 }
 
 static int output_cat(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -847,6 +912,7 @@
         size_t l;
         int r;
 
+        assert(formatter);
         assert(j);
         assert(f);
 
@@ -869,13 +935,110 @@
         return 0;
 }
 
-static int (*output_funcs[_OUTPUT_MODE_MAX])(
+static int output_format(
+                OutputFormatter *formatter,
                 FILE *f,
-                sd_journal*j,
-                OutputMode mode,
+                sd_journal *j,
                 unsigned n_columns,
-                OutputFlags flags) = {
+                OutputFlags flags) {
+
+        size_t i;
+        const void *data;
+        size_t l;
+        int r;
+        uint64_t t;
+        bool truncated;
+
+        assert(formatter);
+        assert(j);
+        assert(f);
+
+        sd_journal_set_data_threshold(j, 0);
+
+        for (i = 0 ; i < formatter->nfields ; i++) {
+                switch (formatter->fields[i].type) {
+                case OUTPUT_FIELD_LITERAL:
+                        fputs(formatter->fields[i].data, f);
+                        break;
+
+                case OUTPUT_FIELD_DATE:
+                case OUTPUT_FIELD_DATE_PRECISE:
+                case OUTPUT_FIELD_DATE_ISO:
+                case OUTPUT_FIELD_DATE_RAW:
+                        if (streq(formatter->fields[i].data, "__MONOTONIC_TIMESTAMP")) {
+                                sd_id128_t boot_id;
+                                r = sd_journal_get_monotonic_usec(j, &t, &boot_id);
+                        } else if (streq(formatter->fields[i].data, "__REALTIME_TIMESTAMP")) {
+                                r = sd_journal_get_realtime_usec(j, &t);
+                        } else {
+                                r = sd_journal_get_data(j, formatter->fields[i].data, &data, &l);
+
+                                if (r > 0) {
+                                        assert(l >= formatter->fields[i].datalen);
+                                        r = safe_atou64((const char *)data + formatter->fields[i].datalen + 1, &t);
+                                }
+                        }
+
+                        if (r < 0) {
+                                if (r == -ENOENT)
+                                        continue;
+
+                                log_error("Failed to get %s: %s", formatter->fields[i].data, strerror(-r));
+                                return r;
+                        }
+
+                        r = print_time(t, formatter->fields[i].type, f);
+                        if (r < 0)
+                                return r;
+                        break;
+
+                case OUTPUT_FIELD_RAW:
+                        sd_journal_set_data_threshold(j, 0);
+
+                        r = sd_journal_get_data(j, formatter->fields[i].data, &data, &l);
+                        if (r < 0) {
+                                if (r == -ENOENT)
+                                        continue;
+
+                                log_error("Failed to get data: %s", strerror(-r));
+                                        return r;
+                        }
+
+                        assert(l >= formatter->fields[i].datalen);
+
+                        data = ((const char *)data) + formatter->fields[i].datalen + 1;
+                        l -= formatter->fields[i].datalen + 1;
+
+                        if (formatter->fields[i].vallen != 0 && l > formatter->fields[i].vallen) {
+                                l = formatter->fields[i].vallen;
+                                        truncated = true;
+                        } else {
+                                truncated = false;
+                        }
 
+                        if (formatter->fields[i].type == OUTPUT_FIELD_RAW) {
+                                fwrite((const char*) data, 1, l, f);
+                        } else {
+                                if (((const char *)data)[l - 1] == '\n')
+                                        l--;
+
+                                if (!utf8_is_printable(data, l)) {
+                                        char bytes[FORMAT_BYTES_MAX];
+                                        fprintf(f, "[%s blob data]", format_bytes(bytes, sizeof(bytes), l));
+                                } else {
+                                        fwrite((const char*) data, 1, l, f);
+                                }
+                                if (truncated)
+                                        fputs("...", f);
+                        }
+                        break;
+                }
+        }
+
+        return 0;
+}
+
+static OutputFunc output_funcs[_OUTPUT_MODE_MAX] = {
         [OUTPUT_SHORT] = output_short,
         [OUTPUT_SHORT_ISO] = output_short,
         [OUTPUT_SHORT_PRECISE] = output_short,
@@ -885,25 +1048,25 @@
         [OUTPUT_JSON] = output_json,
         [OUTPUT_JSON_PRETTY] = output_json,
         [OUTPUT_JSON_SSE] = output_json,
-        [OUTPUT_CAT] = output_cat
+        [OUTPUT_CAT] = output_cat,
+        [OUTPUT_FORMAT] = output_format,
 };
 
 int output_journal(
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
+                OutputFormatter *formatter,
                 unsigned n_columns,
                 OutputFlags flags,
                 bool *ellipsized) {
 
         int ret;
-        assert(mode >= 0);
-        assert(mode < _OUTPUT_MODE_MAX);
+        assert(formatter);
 
         if (n_columns <= 0)
                 n_columns = columns();
 
-        ret = output_funcs[mode](f, j, mode, n_columns, flags);
+        ret = formatter->handler(formatter, f, j, n_columns, flags);
         fflush(stdout);
 
         if (ellipsized && ret > 0)
@@ -929,7 +1092,7 @@
 
 static int show_journal(FILE *f,
                         sd_journal *j,
-                        OutputMode mode,
+                        OutputFormatter *formatter,
                         unsigned n_columns,
                         usec_t not_before,
                         unsigned how_many,
@@ -942,8 +1105,7 @@
         int warn_cutoff = flags & OUTPUT_WARN_CUTOFF;
 
         assert(j);
-        assert(mode >= 0);
-        assert(mode < _OUTPUT_MODE_MAX);
+        assert(formatter);
 
         /* Seek to end */
         r = sd_journal_seek_tail(j);
@@ -986,7 +1148,7 @@
                         line ++;
                         maybe_print_begin_newline(f, &flags);
 
-                        r = output_journal(f, j, mode, n_columns, flags, ellipsized);
+                        r = output_journal(f, j, formatter, n_columns, flags, ellipsized);
                         if (r < 0)
                                 return r;
                 }
@@ -1227,7 +1389,7 @@
 int show_journal_by_unit(
                 FILE *f,
                 const char *unit,
-                OutputMode mode,
+                OutputFormatter *formatter,
                 unsigned n_columns,
                 usec_t not_before,
                 unsigned how_many,
@@ -1240,8 +1402,7 @@
         _cleanup_journal_close_ sd_journal*j = NULL;
         int r;
 
-        assert(mode >= 0);
-        assert(mode < _OUTPUT_MODE_MAX);
+        assert(formatter);
         assert(unit);
 
         if (how_many <= 0)
@@ -1272,7 +1433,7 @@
                 log_debug("Journal filter: %s", filter);
         }
 
-        return show_journal(f, j, mode, n_columns, not_before, how_many, flags, ellipsized);
+        return show_journal(f, j, formatter, n_columns, not_before, how_many, flags, ellipsized);
 }
 
 static const char *const output_mode_table[_OUTPUT_MODE_MAX] = {
@@ -1285,7 +1446,183 @@
         [OUTPUT_JSON] = "json",
         [OUTPUT_JSON_PRETTY] = "json-pretty",
         [OUTPUT_JSON_SSE] = "json-sse",
-        [OUTPUT_CAT] = "cat"
+        [OUTPUT_CAT] = "cat",
+        [OUTPUT_FORMAT] = "format",
 };
 
 DEFINE_STRING_TABLE_LOOKUP(output_mode, OutputMode);
+
+void output_formatter_free(OutputFormatter **formatter) {
+        if (!*formatter)
+                return;
+
+        free(*formatter);
+        *formatter = NULL;
+}
+
+static int output_formatter_add_field(OutputFormatter *formatter,
+        OutputFieldType type,
+        size_t vallen,
+        char *data,
+        size_t datalen)
+{
+        OutputField *fields;
+
+        fields = realloc_multiply(formatter->fields,
+        sizeof(OutputField),
+        formatter->nfields + 1);
+        if (!fields)
+                return -ENOMEM;
+
+        fields[formatter->nfields].type = type;
+        fields[formatter->nfields].vallen = vallen;
+        fields[formatter->nfields].data = data;
+        fields[formatter->nfields].datalen = datalen;
+        formatter->fields = fields;
+        formatter->nfields++;
+
+        return 0;
+}
+
+static int output_formatter_parse_format(OutputFormatter *formatter, const char *format) {
+        const char *prev = format;
+        char *final_newline;
+        int r;
+
+        do {
+                const char *next;
+                char *data;
+                size_t datalen;
+
+                next = strstr(format, "{");
+
+                if (!next || next != prev) {
+                        datalen = next ? (size_t)(next - prev) : strlen(prev);
+                        data = strndup(prev, datalen);
+
+                        if ((r = output_formatter_add_field(formatter, OUTPUT_FIELD_LITERAL, 0, data, datalen)) < 0) {
+                                free(data);
+                                return r;
+                        }
+                }
+
+                if (next) {
+                        const char *end;
+                        OutputFieldType type;
+                        char *optstr;
+                        uint64_t vallen = 0;
+
+                        end = strchr(next, '}');
+                        if (!end)
+                                return -EINVAL;
+
+                        datalen = (end - (next + 1));
+                        data = strndup(next + 1, datalen);
+
+                        if ((optstr = strchr(data, ':')) != NULL) {
+                                datalen = optstr - data;
+                                *optstr = '\0';
+                                optstr++;
+
+                                if (streq(optstr, "date"))
+                                        type = OUTPUT_FIELD_DATE;
+                                else if (streq(optstr, "date-precise"))
+                                        type = OUTPUT_FIELD_DATE_PRECISE;
+                                else if (streq(optstr, "date-iso"))
+                                        type = OUTPUT_FIELD_DATE_ISO;
+                                else if (streq(optstr, "date-raw"))
+                                        type = OUTPUT_FIELD_DATE_RAW;
+                                else if (safe_atou64(optstr, &vallen) >= 0)
+                                        type = OUTPUT_FIELD_RAW;
+                                else {
+                                        free(data);
+                                        return -EINVAL;
+                                }
+
+                        } else {
+                                if (streq(data, "__REALTIME_TIMESTAMP"))
+                                        type = OUTPUT_FIELD_DATE;
+                                else
+                                        type = OUTPUT_FIELD_RAW;
+                        }
+
+                        if ((r = output_formatter_add_field(formatter, type, vallen, data, datalen)) < 0) {
+                                free(data);
+                                return r;
+                        }
+                        format = end + 1;
+                        prev = end + 1;
+                } else {
+                        format = NULL;
+                }
+        } while (format && *format);
+
+        final_newline = (char *) malloc( 2 * sizeof(char) );
+        strncpy(final_newline, "\n", 2);
+        if ((r = output_formatter_add_field(formatter, OUTPUT_FIELD_LITERAL, 0, final_newline, 2)) < 0){
+                free(final_newline);
+                return r;
+        }
+
+        return 0;
+}
+
+#define DEFAULT_FORMAT "{__REALTIME_TIMESTAMP} {_HOSTNAME} {SYSLOG_IDENTIFIER}[{_PID}]: {MESSAGE}"
+
+int output_formatter_from_mode(OutputMode mode, OutputFormatter **formatter)
+{
+        int r;
+        _cleanup_output_formatter_ OutputFormatter *ret = NULL;
+
+        assert(mode >= 0);
+        assert(mode < _OUTPUT_MODE_MAX);
+        assert(formatter);
+        assert(!*formatter);
+
+        if (!(ret = new(OutputFormatter, 1)))
+                return -ENOMEM;
+
+        ret->mode = mode;
+        if (ret->mode == OUTPUT_FORMAT &&  ((r = output_formatter_parse_format(ret, DEFAULT_FORMAT)) < 0))
+                return r;
+        ret->handler = output_funcs[ret->mode];
+
+        *formatter = ret;
+        ret = NULL;
+        return 0;
+}
+
+int output_formatter_from_string(const char *arg, OutputFormatter **formatter) {
+        int r;
+        _cleanup_output_formatter_ OutputFormatter *ret = NULL;
+
+        assert(arg);
+        assert(formatter);
+        assert(!*formatter);
+
+        if (!(ret = new(OutputFormatter, 1)))
+                return -ENOMEM;
+
+        if (strneq(arg, "format:", 7)) {
+                ret->mode = OUTPUT_FORMAT;
+                if ((r = output_formatter_parse_format(ret, arg + 7)) < 0)
+                        return r;
+        } else {
+                if ((ret->mode = output_mode_from_string(arg)) < 0)
+                        return -EINVAL;
+
+                if (ret->mode == OUTPUT_FORMAT && ((r = output_formatter_parse_format(ret, DEFAULT_FORMAT)) < 0))
+                        return r;
+        }
+        ret->handler = output_funcs[ret->mode];
+
+        *formatter = ret;
+        ret = NULL;
+        return 0;
+}
+
+OutputMode output_formatter_get_mode(OutputFormatter *formatter) {
+        assert(formatter);
+
+        return formatter->mode;
+}
Index: git/src/shared/logs-show.h
===================================================================
--- git.orig/src/shared/logs-show.h	2015-11-14 23:11:22.859799467 +0000
+++ git/src/shared/logs-show.h	2015-11-14 23:11:22.851799467 +0000
@@ -29,10 +29,12 @@
 #include "util.h"
 #include "output-mode.h"
 
+typedef struct _OutputFormatter OutputFormatter;
+
 int output_journal(
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
+                OutputFormatter *formatter,
                 unsigned n_columns,
                 OutputFlags flags,
                 bool *ellipsized);
@@ -51,7 +53,7 @@
 int show_journal_by_unit(
                 FILE *f,
                 const char *unit,
-                OutputMode mode,
+                OutputFormatter *formatter,
                 unsigned n_columns,
                 usec_t not_before,
                 unsigned how_many,
@@ -69,3 +71,11 @@
 
 const char* output_mode_to_string(OutputMode m) _const_;
 OutputMode output_mode_from_string(const char *s) _pure_;
+
+int output_formatter_from_string(const char *arg, OutputFormatter **formatter);
+int output_formatter_from_mode(OutputMode mode, OutputFormatter **formatter);
+
+OutputMode output_formatter_get_mode(OutputFormatter *formatter);
+
+void output_formatter_free(OutputFormatter **formatter);
+#define _cleanup_output_formatter_ _cleanup_(output_formatter_free)
Index: git/src/shared/output-mode.h
===================================================================
--- git.orig/src/shared/output-mode.h	2015-11-14 23:11:22.859799467 +0000
+++ git/src/shared/output-mode.h	2015-11-14 23:11:22.855799467 +0000
@@ -32,6 +32,7 @@
         OUTPUT_JSON_PRETTY,
         OUTPUT_JSON_SSE,
         OUTPUT_CAT,
+        OUTPUT_FORMAT,
         _OUTPUT_MODE_MAX,
         _OUTPUT_MODE_INVALID = -1
 } OutputMode;
Index: git/src/systemctl/systemctl.c
===================================================================
--- git.orig/src/systemctl/systemctl.c	2015-11-14 23:11:22.859799467 +0000
+++ git/src/systemctl/systemctl.c	2015-11-14 23:15:15.819794775 +0000
@@ -135,7 +135,8 @@
 static BusTransport arg_transport = BUS_TRANSPORT_LOCAL;
 static char *arg_host = NULL;
 static unsigned arg_lines = 10;
-static OutputMode arg_output = OUTPUT_SHORT;
+static const char *arg_output = "short";
+static OutputFormatter *arg_formatter = NULL;
 static bool arg_plain = false;
 static bool arg_firmware_setup = false;
 static bool arg_now = false;
@@ -3587,7 +3588,7 @@
                 show_journal_by_unit(
                                 stdout,
                                 i->id,
-                                arg_output,
+                                arg_formatter,
                                 0,
                                 i->inactive_exit_timestamp_monotonic,
                                 arg_lines,
@@ -6104,7 +6105,8 @@
                "  -n --lines=INTEGER  Number of journal entries to show\n"
                "  -o --output=STRING  Change journal output mode (short, short-iso,\n"
                "                              short-precise, short-monotonic, verbose,\n"
-               "                              export, json, json-pretty, json-sse, cat)\n"
+               "                              export, json, json-pretty, json-sse, cat,\n"
+               "                              format:FORMAT-STRING)\n"
                "     --firmware-setup Tell the firmware to show the setup menu on next boot\n"
                "     --plain          Print unit dependencies as a list instead of a tree\n\n"
                "Unit Commands:\n"
@@ -6337,6 +6339,7 @@
         };
 
         int c;
+        int err;
 
         assert(argc >= 0);
         assert(argv);
@@ -6558,11 +6561,7 @@
                         break;
 
                 case 'o':
-                        arg_output = output_mode_from_string(optarg);
-                        if (arg_output < 0) {
-                                log_error("Unknown output '%s'.", optarg);
-                                return -EINVAL;
-                        }
+                        arg_output = optarg;
                         break;
 
                 case 'i':
@@ -6634,6 +6633,11 @@
                 return -EINVAL;
         }
 
+        if ((err = output_formatter_from_string(arg_output, &arg_formatter)) < 0) {
+            log_error("Unknown / malformed output format '%s'.", arg_output);
+            return err;
+        }
+
         return 1;
 }
 
