From 7fbc2e59f4c5085ed52bd6d0813cdaab0cded502 Mon Sep 17 00:00:00 2001
From: Tobias Hintze <thintze+git@tpip.net>
Date: Fri, 28 Oct 2016 14:04:26 +0200
Subject: [PATCH] add log formatter feature

(patch forward-ported)
The relevant option is the '-o' flag which can be called with a formatter
string, e.g.

    journalctl -o "format:{__REALTIME_TIMESTAMP:date} {MESSAGE:60}"

which will output the date (a formatted Unix timestamp) and the message
(truncated to 60 characters). Literals are also allowed outside of the curly
braces. There are only the mentioned two options - date formatting and
string truncating - available. Those cannot be mixed.

The possible date formats are

    - date              Okt 20 10:22:05
    - date-iso          2015-10-20T10:22:05+0200
    - date-precise      Okt 20 10:22:05.056146
    - date-raw          [1445329325.056146]

where 'date' is the default on "__REALTIME_TIMESTAMP".

---
 src/journal-remote/journal-gatewayd.c |   8 +-
 src/journal/journalctl.c              |  38 +--
 src/login/loginctl.c                  |  22 +-
 src/machine/machinectl.c              |  19 +-
 src/shared/logs-show.c                | 447 ++++++++++++++++++++++++++++++----
 src/shared/logs-show.h                |  14 +-
 src/shared/output-mode.h              |   1 +
 src/systemctl/systemctl.c             |  20 +-
 8 files changed, 471 insertions(+), 98 deletions(-)

diff --git a/src/journal-remote/journal-gatewayd.c b/src/journal-remote/journal-gatewayd.c
index 60d8977..23600c9 100644
--- a/src/journal-remote/journal-gatewayd.c
+++ b/src/journal-remote/journal-gatewayd.c
@@ -150,6 +150,7 @@ static ssize_t request_reader_entries(
         RequestMeta *m = cls;
         int r;
         size_t n, k;
+        _cleanup_output_formatter_ OutputFormatter *output_formatter = NULL;
 
         assert(m);
         assert(buf);
@@ -158,6 +159,11 @@ static ssize_t request_reader_entries(
 
         pos -= m->delta;
 
+        if ((r = output_formatter_from_mode(m->mode, &output_formatter)) < 0) {
+                log_error("Failed to parse mode: %s", strerror(-r));
+                return MHD_CONTENT_READER_END_WITH_ERROR;
+        }
+
         while (pos >= m->size) {
                 off_t sz;
 
@@ -222,7 +228,7 @@ static ssize_t request_reader_entries(
                         return MHD_CONTENT_READER_END_WITH_ERROR;
                 }
 
-                r = output_journal(m->tmp, m->journal, m->mode, 0, OUTPUT_FULL_WIDTH, NULL);
+                r = output_journal(m->tmp, m->journal, output_formatter, 0, OUTPUT_FULL_WIDTH, NULL);
                 if (r < 0) {
                         log_error_errno(r, "Failed to serialize item: %m");
                         return MHD_CONTENT_READER_END_WITH_ERROR;
diff --git a/src/journal/journalctl.c b/src/journal/journalctl.c
index 273242b..55f4dc2 100644
--- a/src/journal/journalctl.c
+++ b/src/journal/journalctl.c
@@ -80,7 +80,8 @@ enum {
         ARG_LINES_ALL = -1,
 };
 
-static OutputMode arg_output = OUTPUT_SHORT;
+static const char *arg_output = "short";
+static OutputFormatter *arg_formatter = NULL;
 static bool arg_utc = false;
 static bool arg_pager_end = false;
 static bool arg_follow = false;
@@ -305,7 +306,8 @@ static void help(void) {
                "  -r --reverse             Show the newest entries first\n"
                "  -o --output=STRING       Change journal output mode (short, short-iso,\n"
                "                                   short-precise, short-monotonic, verbose,\n"
-               "                                   export, json, json-pretty, json-sse, cat)\n"
+               "                                   export, json, json-pretty, json-sse, cat,\n"
+               "                                   format:FORMAT-STRING)\n"
                "     --utc                 Express time in Coordinated Universal Time (UTC)\n"
                "  -x --catalog             Add message explanations where available\n"
                "     --no-full             Ellipsize fields\n"
@@ -439,6 +441,8 @@ static int parse_argv(int argc, char *argv[]) {
         };
 
         int c, r;
+        int err;
+        OutputMode mode;
 
         assert(argc >= 0);
         assert(argv);
@@ -471,19 +475,7 @@ static int parse_argv(int argc, char *argv[]) {
                         break;
 
                 case 'o':
-                        arg_output = output_mode_from_string(optarg);
-                        if (arg_output < 0) {
-                                log_error("Unknown output format '%s'.", optarg);
-                                return -EINVAL;
-                        }
-
-                        if (arg_output == OUTPUT_EXPORT ||
-                            arg_output == OUTPUT_JSON ||
-                            arg_output == OUTPUT_JSON_PRETTY ||
-                            arg_output == OUTPUT_JSON_SSE ||
-                            arg_output == OUTPUT_CAT)
-                                arg_quiet = true;
-
+                        arg_output = optarg;
                         break;
 
                 case 'l':
@@ -831,6 +823,20 @@ static int parse_argv(int argc, char *argv[]) {
                         assert_not_reached("Unhandled option");
                 }
 
+        if ((err = output_formatter_from_string(arg_output,
+                &arg_formatter)) < 0) {
+                log_error("Unknown/malformed output format '%s'.", arg_output);
+                return err;
+        }
+
+        mode = output_formatter_get_mode(arg_formatter);
+        if (mode == OUTPUT_EXPORT ||
+            mode == OUTPUT_JSON ||
+            mode == OUTPUT_JSON_PRETTY ||
+            mode == OUTPUT_JSON_SSE ||
+            mode == OUTPUT_CAT)
+                arg_quiet = true;
+
         if (arg_follow && !arg_no_tail && !arg_since && arg_lines == ARG_LINES_DEFAULT)
                 arg_lines = 10;
 
@@ -2454,7 +2460,7 @@ int main(int argc, char *argv[]) {
                                 arg_catalog * OUTPUT_CATALOG |
                                 arg_utc * OUTPUT_UTC;
 
-                        r = output_journal(stdout, j, arg_output, 0, flags, &ellipsized);
+                        r = output_journal(stdout, j, arg_formatter, 0, flags, &ellipsized);
                         need_seek = true;
                         if (r == -EADDRNOTAVAIL)
                                 break;
diff --git a/src/login/loginctl.c b/src/login/loginctl.c
index 6ad3d08..ca0e4ac 100644
--- a/src/login/loginctl.c
+++ b/src/login/loginctl.c
@@ -57,7 +57,8 @@ static BusTransport arg_transport = BUS_TRANSPORT_LOCAL;
 static char *arg_host = NULL;
 static bool arg_ask_password = true;
 static unsigned arg_lines = 10;
-static OutputMode arg_output = OUTPUT_SHORT;
+static const char *arg_output = "short";
+static OutputFormatter *arg_formatter = NULL;
 
 static void pager_open_if_enabled(void) {
 
@@ -539,7 +540,7 @@ static int print_session_status_info(sd_bus *bus, const char *path, bool *new_li
                         show_journal_by_unit(
                                         stdout,
                                         i.scope,
-                                        arg_output,
+                                        arg_formatter,
                                         0,
                                         i.timestamp.monotonic,
                                         arg_lines,
@@ -619,7 +620,7 @@ static int print_user_status_info(sd_bus *bus, const char *path, bool *new_line)
                 show_journal_by_unit(
                                 stdout,
                                 i.slice,
-                                arg_output,
+                                arg_formatter,
                                 0,
                                 i.timestamp.monotonic,
                                 arg_lines,
@@ -1343,7 +1344,8 @@ static int help(int argc, char *argv[], void *userdata) {
                "  -s --signal=SIGNAL       Which signal to send\n"
                "  -n --lines=INTEGER       Number of journal entries to show\n"
                "  -o --output=STRING       Change journal output mode (short, short-monotonic,\n"
-               "                           verbose, export, json, json-pretty, json-sse, cat)\n\n"
+               "                           verbose, export, json, json-pretty, json-sse, cat,\n\n"
+               "                           format:FORMAT-STRING)\n"
                "Session Commands:\n"
                "  list-sessions            List sessions\n"
                "  session-status [ID...]   Show session status\n"
@@ -1404,6 +1406,7 @@ static int parse_argv(int argc, char *argv[]) {
         };
 
         int c, r;
+        int err;
 
         assert(argc >= 0);
         assert(argv);
@@ -1447,11 +1450,7 @@ static int parse_argv(int argc, char *argv[]) {
                         break;
 
                 case 'o':
-                        arg_output = output_mode_from_string(optarg);
-                        if (arg_output < 0) {
-                                log_error("Unknown output '%s'.", optarg);
-                                return -EINVAL;
-                        }
+                        arg_output = optarg;
                         break;
 
                 case ARG_NO_PAGER:
@@ -1495,6 +1494,11 @@ static int parse_argv(int argc, char *argv[]) {
                         assert_not_reached("Unhandled option");
                 }
 
+        if ((err = output_formatter_from_string(arg_output, &arg_formatter)) < 0) {
+                log_error("Unknown / malformed output format '%s'.", arg_output);
+                return err;
+        }
+
         return 1;
 }
 
diff --git a/src/machine/machinectl.c b/src/machine/machinectl.c
index 4853139..ccdf08c 100644
--- a/src/machine/machinectl.c
+++ b/src/machine/machinectl.c
@@ -73,7 +73,8 @@ static bool arg_mkdir = false;
 static bool arg_quiet = false;
 static bool arg_ask_password = true;
 static unsigned arg_lines = 10;
-static OutputMode arg_output = OUTPUT_SHORT;
+static const char *arg_output = "short";
+static OutputFormatter *arg_formatter = NULL;
 static bool arg_force = false;
 static ImportVerify arg_verify = IMPORT_VERIFY_SIGNATURE;
 static const char* arg_format = NULL;
@@ -602,7 +603,7 @@ static void print_machine_status_info(sd_bus *bus, MachineStatusInfo *i) {
                         show_journal_by_unit(
                                         stdout,
                                         i->unit,
-                                        arg_output,
+                                        arg_formatter,
                                         0,
                                         i->timestamp.monotonic,
                                         arg_lines,
@@ -2374,7 +2375,7 @@ static int help(int argc, char *argv[], void *userdata) {
                "  -n --lines=INTEGER          Number of journal entries to show\n"
                "  -o --output=STRING          Change journal output mode (short,\n"
                "                              short-monotonic, verbose, export, json,\n"
-               "                              json-pretty, json-sse, cat)\n"
+               "                              json-pretty, json-sse, cat, format:FORMAT-STRING)\n"
                "      --verify=MODE           Verification mode for downloaded images (no,\n"
                "                              checksum, signature)\n"
                "      --force                 Download image even if already exists\n\n"
@@ -2464,6 +2465,7 @@ static int parse_argv(int argc, char *argv[]) {
         };
 
         int c, r;
+        int err;
 
         assert(argc >= 0);
         assert(argv);
@@ -2505,11 +2507,7 @@ static int parse_argv(int argc, char *argv[]) {
                         break;
 
                 case 'o':
-                        arg_output = output_mode_from_string(optarg);
-                        if (arg_output < 0) {
-                                log_error("Unknown output '%s'.", optarg);
-                                return -EINVAL;
-                        }
+                        arg_output = optarg;
                         break;
 
                 case ARG_NO_PAGER:
@@ -2601,6 +2599,11 @@ static int parse_argv(int argc, char *argv[]) {
                         assert_not_reached("Unhandled option");
                 }
 
+        if ((err = output_formatter_from_string(arg_output, &arg_formatter)) < 0) {
+                log_error("Unknown / malformed output format '%s'.", arg_output);
+                return err;
+        }
+
         return 1;
 }
 
diff --git a/src/shared/logs-show.c b/src/shared/logs-show.c
index 5eb3bd3..c074277 100644
--- a/src/shared/logs-show.c
+++ b/src/shared/logs-show.c
@@ -58,6 +58,35 @@
 
 #define JSON_THRESHOLD 4096
 
+typedef int (*OutputFunc)(OutputFormatter *formatter,
+                          FILE *f,
+                          sd_journal*j,
+                          unsigned n_columns,
+                          OutputFlags flags);
+
+typedef enum {
+        OUTPUT_FIELD_LITERAL,      /* data is a literal string to print */
+        OUTPUT_FIELD_DATE,         /* data is a variable to show as a simple date */
+        OUTPUT_FIELD_DATE_PRECISE, /* data is a variable to show as a precise date */
+        OUTPUT_FIELD_DATE_ISO,     /* data is a variable to show as a ISO date */
+        OUTPUT_FIELD_DATE_RAW,     /* data is a variable to show as a RAW timestamp */
+        OUTPUT_FIELD_RAW,          /* data is a variable to show as a raw string */
+} OutputFieldType;
+
+typedef struct _OutputField {
+        OutputFieldType type;
+        size_t vallen; /* Truncate value to this length when printing */
+        const char *data;
+        size_t datalen;
+} OutputField;
+
+struct _OutputFormatter {
+        OutputFunc handler;
+        OutputMode mode;
+        size_t nfields;
+        OutputField *fields;
+};
+
 static int print_catalog(FILE *f, sd_journal *j) {
         int r;
         _cleanup_free_ char *t = NULL, *z = NULL;
@@ -206,10 +235,57 @@ static bool print_multiline(FILE *f, unsigned prefix, unsigned n_columns, Output
         return ellipsized;
 }
 
+static int print_time(uint64_t ts, OutputFieldType type, FILE *f) {
+        int n, r;
+        char buf[64];
+        time_t t;
+        struct tm tm;
+
+        assert(f);
+
+        t = (time_t)(ts / USEC_PER_SEC);
+
+        switch (type) {
+        case OUTPUT_FIELD_DATE:
+                r = strftime(buf, sizeof(buf), "%b %d %H:%M:%S", localtime_r(&t, &tm));
+                break;
+
+        case OUTPUT_FIELD_DATE_PRECISE:
+                r = strftime(buf, sizeof(buf), "%b %d %H:%M:%S", localtime_r(&t, &tm));
+                if (r > 0) {
+                        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
+                                 ".%06llu", (unsigned long long) (ts % USEC_PER_SEC));
+                }
+                break;
+
+        case OUTPUT_FIELD_DATE_ISO:
+                r = strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S%z", localtime_r(&t, &tm));
+                break;
+
+        case OUTPUT_FIELD_DATE_RAW:
+                r = snprintf(buf, sizeof(buf), "[%5llu.%06llu]",
+                             (unsigned long long) (ts / USEC_PER_SEC),
+                             (unsigned long long) (ts % USEC_PER_SEC));
+                break;
+
+        default:
+                return -EINVAL;
+        }
+
+        if (r <= 0) {
+                log_error("Failed to format time.");
+                return -EINVAL;
+        }
+        fputs(buf, f);
+        n = strlen(buf);
+
+        return n;
+}
+
 static int output_short(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -222,6 +298,7 @@ static int output_short(
         int p = LOG_INFO;
         bool ellipsized = false;
 
+        assert(formatter);
         assert(f);
         assert(j);
 
@@ -302,7 +379,7 @@ static int output_short(
         if (priority_len == 1 && *priority >= '0' && *priority <= '7')
                 p = *priority - '0';
 
-        if (mode == OUTPUT_SHORT_MONOTONIC) {
+        if (formatter->mode == OUTPUT_SHORT_MONOTONIC) {
                 uint64_t t;
                 sd_id128_t boot_id;
 
@@ -317,21 +394,15 @@ static int output_short(
                 if (r < 0)
                         return log_error_errno(r, "Failed to get monotonic timestamp: %m");
 
-                fprintf(f, "[%5llu.%06llu]",
-                        (unsigned long long) (t / USEC_PER_SEC),
-                        (unsigned long long) (t % USEC_PER_SEC));
+                if ((r = print_time(t, OUTPUT_FIELD_DATE_RAW, f)) < 0)
+                        return log_error_errno(r, "Failed to format monotonic timestamp: %m");
 
-                n += 1 + 5 + 1 + 6 + 1;
+                n += r;
 
         } else {
-                char buf[64];
                 uint64_t x;
-                time_t t;
-                struct tm tm;
-                struct tm *(*gettime_r)(const time_t *, struct tm *);
 
                 r = -ENOENT;
-                gettime_r = (flags & OUTPUT_UTC) ? gmtime_r : localtime_r;
 
                 if (realtime)
                         r = safe_atou64(realtime, &x);
@@ -342,29 +413,22 @@ static int output_short(
                 if (r < 0)
                         return log_error_errno(r, "Failed to get realtime timestamp: %m");
 
-                t = (time_t) (x / USEC_PER_SEC);
-
-                switch(mode) {
+                switch(formatter->mode) {
                 case OUTPUT_SHORT_ISO:
-                        r = strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S%z", gettime_r(&t, &tm));
+                        if ((r = print_time(x, OUTPUT_FIELD_DATE_ISO, f)) < 0)
+                                return log_error_errno(r, "Failed to format time as iso timestamp: %m");
                         break;
                 case OUTPUT_SHORT_PRECISE:
-                        r = strftime(buf, sizeof(buf), "%b %d %H:%M:%S", gettime_r(&t, &tm));
-                        if (r > 0)
-                                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
-                                         ".%06llu", (unsigned long long) (x % USEC_PER_SEC));
+                        if ((r = print_time(x, OUTPUT_FIELD_DATE_PRECISE, f)) < 0)
+                                return log_error_errno(r, "Failed to format time as precise timestamp: %m");
                         break;
                 default:
-                        r = strftime(buf, sizeof(buf), "%b %d %H:%M:%S", gettime_r(&t, &tm));
-                }
-
-                if (r <= 0) {
-                        log_error("Failed to format time.");
-                        return -EINVAL;
+                        if ((r = print_time(x, OUTPUT_FIELD_DATE, f)) < 0)
+                                return log_error_errno(r, "Failed to format time as default timestamp: %m");
+                        break;
                 }
 
-                fputs(buf, f);
-                n += strlen(buf);
+                n += r;
         }
 
         if (hostname && shall_print(hostname, hostname_len, flags)) {
@@ -405,9 +469,9 @@ static int output_short(
 }
 
 static int output_verbose(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -418,6 +482,7 @@ static int output_verbose(
         char ts[FORMAT_TIMESTAMP_MAX + 7];
         int r;
 
+        assert(formatter);
         assert(f);
         assert(j);
 
@@ -502,9 +567,9 @@ static int output_verbose(
 }
 
 static int output_export(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -516,6 +581,7 @@ static int output_export(
         const void *data;
         size_t length;
 
+        assert(formatter);
         assert(j);
 
         sd_journal_set_data_threshold(j, 0);
@@ -633,9 +699,9 @@ void json_escape(
 }
 
 static int output_json(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -649,6 +715,7 @@ static int output_json(
         Hashmap *h = NULL;
         bool done, separator;
 
+        assert(formatter);
         assert(j);
 
         sd_journal_set_data_threshold(j, flags & OUTPUT_SHOW_ALL ? 0 : JSON_THRESHOLD);
@@ -665,7 +732,7 @@ static int output_json(
         if (r < 0)
                 return log_error_errno(r, "Failed to get cursor: %m");
 
-        if (mode == OUTPUT_JSON_PRETTY)
+        if (formatter->mode == OUTPUT_JSON_PRETTY)
                 fprintf(f,
                         "{\n"
                         "\t\"__CURSOR\" : \"%s\",\n"
@@ -677,7 +744,7 @@ static int output_json(
                         monotonic,
                         sd_id128_to_string(boot_id, sid));
         else {
-                if (mode == OUTPUT_JSON_SSE)
+                if (formatter->mode == OUTPUT_JSON_SSE)
                         fputs("data: ", f);
 
                 fprintf(f,
@@ -757,7 +824,7 @@ static int output_json(
                                 continue;
 
                         if (separator) {
-                                if (mode == OUTPUT_JSON_PRETTY)
+                                if (formatter->mode == OUTPUT_JSON_PRETTY)
                                         fputs(",\n\t", f);
                                 else
                                         fputs(", ", f);
@@ -832,9 +899,9 @@ static int output_json(
 
         } while (!done);
 
-        if (mode == OUTPUT_JSON_PRETTY)
+        if (formatter->mode == OUTPUT_JSON_PRETTY)
                 fputs("\n}\n", f);
-        else if (mode == OUTPUT_JSON_SSE)
+        else if (formatter->mode == OUTPUT_JSON_SSE)
                 fputs("}\n\n", f);
         else
                 fputs(" }\n", f);
@@ -851,9 +918,9 @@ finish:
 }
 
 static int output_cat(
+                OutputFormatter *formatter,
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
                 unsigned n_columns,
                 OutputFlags flags) {
 
@@ -861,6 +928,7 @@ static int output_cat(
         size_t l;
         int r;
 
+        assert(formatter);
         assert(j);
         assert(f);
 
@@ -883,13 +951,110 @@ static int output_cat(
         return 0;
 }
 
-static int (*output_funcs[_OUTPUT_MODE_MAX])(
+static int output_format(
+                OutputFormatter *formatter,
                 FILE *f,
-                sd_journal*j,
-                OutputMode mode,
+                sd_journal *j,
                 unsigned n_columns,
-                OutputFlags flags) = {
+                OutputFlags flags) {
+
+        size_t i;
+        const void *data;
+        size_t l;
+        int r;
+        uint64_t t;
+        bool truncated;
+
+        assert(formatter);
+        assert(j);
+        assert(f);
+
+        sd_journal_set_data_threshold(j, 0);
+
+        for (i = 0 ; i < formatter->nfields ; i++) {
+                switch (formatter->fields[i].type) {
+                case OUTPUT_FIELD_LITERAL:
+                        fputs(formatter->fields[i].data, f);
+                        break;
+
+                case OUTPUT_FIELD_DATE:
+                case OUTPUT_FIELD_DATE_PRECISE:
+                case OUTPUT_FIELD_DATE_ISO:
+                case OUTPUT_FIELD_DATE_RAW:
+                        if (streq(formatter->fields[i].data, "__MONOTONIC_TIMESTAMP")) {
+                                sd_id128_t boot_id;
+                                r = sd_journal_get_monotonic_usec(j, &t, &boot_id);
+                        } else if (streq(formatter->fields[i].data, "__REALTIME_TIMESTAMP")) {
+                                r = sd_journal_get_realtime_usec(j, &t);
+                        } else {
+                                r = sd_journal_get_data(j, formatter->fields[i].data, &data, &l);
+
+                                if (r > 0) {
+                                        assert(l >= formatter->fields[i].datalen);
+                                        r = safe_atou64((const char *)data + formatter->fields[i].datalen + 1, &t);
+                                }
+                        }
+
+                        if (r < 0) {
+                                if (r == -ENOENT)
+                                        continue;
+
+                                log_error("Failed to get %s: %s", formatter->fields[i].data, strerror(-r));
+                                return r;
+                        }
+
+                        r = print_time(t, formatter->fields[i].type, f);
+                        if (r < 0)
+                                return r;
+                        break;
+
+                case OUTPUT_FIELD_RAW:
+                        sd_journal_set_data_threshold(j, 0);
+
+                        r = sd_journal_get_data(j, formatter->fields[i].data, &data, &l);
+                        if (r < 0) {
+                                if (r == -ENOENT)
+                                        continue;
+
+                                log_error("Failed to get data: %s", strerror(-r));
+                                        return r;
+                        }
+
+                        assert(l >= formatter->fields[i].datalen);
+
+                        data = ((const char *)data) + formatter->fields[i].datalen + 1;
+                        l -= formatter->fields[i].datalen + 1;
+
+                        if (formatter->fields[i].vallen != 0 && l > formatter->fields[i].vallen) {
+                                l = formatter->fields[i].vallen;
+                                        truncated = true;
+                        } else {
+                                truncated = false;
+                        }
+
+                        if (formatter->fields[i].type == OUTPUT_FIELD_RAW) {
+                                fwrite((const char*) data, 1, l, f);
+                        } else {
+                                if (((const char *)data)[l - 1] == '\n')
+                                        l--;
+
+                                if (!utf8_is_printable(data, l)) {
+                                        char bytes[FORMAT_BYTES_MAX];
+                                        fprintf(f, "[%s blob data]", format_bytes(bytes, sizeof(bytes), l));
+                                } else {
+                                        fwrite((const char*) data, 1, l, f);
+                                }
+                                if (truncated)
+                                        fputs("...", f);
+                        }
+                        break;
+                }
+        }
+
+        return 0;
+}
 
+static OutputFunc output_funcs[_OUTPUT_MODE_MAX] = {
         [OUTPUT_SHORT] = output_short,
         [OUTPUT_SHORT_ISO] = output_short,
         [OUTPUT_SHORT_PRECISE] = output_short,
@@ -899,25 +1064,25 @@ static int (*output_funcs[_OUTPUT_MODE_MAX])(
         [OUTPUT_JSON] = output_json,
         [OUTPUT_JSON_PRETTY] = output_json,
         [OUTPUT_JSON_SSE] = output_json,
-        [OUTPUT_CAT] = output_cat
+        [OUTPUT_CAT] = output_cat,
+        [OUTPUT_FORMAT] = output_format,
 };
 
 int output_journal(
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
+                OutputFormatter *formatter,
                 unsigned n_columns,
                 OutputFlags flags,
                 bool *ellipsized) {
 
         int ret;
-        assert(mode >= 0);
-        assert(mode < _OUTPUT_MODE_MAX);
+        assert(formatter);
 
         if (n_columns <= 0)
                 n_columns = columns();
 
-        ret = output_funcs[mode](f, j, mode, n_columns, flags);
+        ret = formatter->handler(formatter, f, j, n_columns, flags);
         fflush(stdout);
 
         if (ellipsized && ret > 0)
@@ -943,7 +1108,7 @@ static int maybe_print_begin_newline(FILE *f, OutputFlags *flags) {
 
 static int show_journal(FILE *f,
                         sd_journal *j,
-                        OutputMode mode,
+                        OutputFormatter *formatter,
                         unsigned n_columns,
                         usec_t not_before,
                         unsigned how_many,
@@ -956,8 +1121,7 @@ static int show_journal(FILE *f,
         int warn_cutoff = flags & OUTPUT_WARN_CUTOFF;
 
         assert(j);
-        assert(mode >= 0);
-        assert(mode < _OUTPUT_MODE_MAX);
+        assert(formatter);
 
         /* Seek to end */
         r = sd_journal_seek_tail(j);
@@ -1000,7 +1164,7 @@ static int show_journal(FILE *f,
                         line ++;
                         maybe_print_begin_newline(f, &flags);
 
-                        r = output_journal(f, j, mode, n_columns, flags, ellipsized);
+                        r = output_journal(f, j, formatter, n_columns, flags, ellipsized);
                         if (r < 0)
                                 return r;
                 }
@@ -1241,7 +1405,7 @@ int add_match_this_boot(sd_journal *j, const char *machine) {
 int show_journal_by_unit(
                 FILE *f,
                 const char *unit,
-                OutputMode mode,
+                OutputFormatter *formatter,
                 unsigned n_columns,
                 usec_t not_before,
                 unsigned how_many,
@@ -1254,8 +1418,7 @@ int show_journal_by_unit(
         _cleanup_(sd_journal_closep) sd_journal *j = NULL;
         int r;
 
-        assert(mode >= 0);
-        assert(mode < _OUTPUT_MODE_MAX);
+        assert(formatter);
         assert(unit);
 
         if (how_many <= 0)
@@ -1286,7 +1449,7 @@ int show_journal_by_unit(
                 log_debug("Journal filter: %s", filter);
         }
 
-        return show_journal(f, j, mode, n_columns, not_before, how_many, flags, ellipsized);
+        return show_journal(f, j, formatter, n_columns, not_before, how_many, flags, ellipsized);
 }
 
 static const char *const output_mode_table[_OUTPUT_MODE_MAX] = {
@@ -1299,7 +1462,183 @@ static const char *const output_mode_table[_OUTPUT_MODE_MAX] = {
         [OUTPUT_JSON] = "json",
         [OUTPUT_JSON_PRETTY] = "json-pretty",
         [OUTPUT_JSON_SSE] = "json-sse",
-        [OUTPUT_CAT] = "cat"
+        [OUTPUT_CAT] = "cat",
+        [OUTPUT_FORMAT] = "format",
 };
 
 DEFINE_STRING_TABLE_LOOKUP(output_mode, OutputMode);
+
+void output_formatter_free(OutputFormatter **formatter) {
+        if (!*formatter)
+                return;
+
+        free(*formatter);
+        *formatter = NULL;
+}
+
+static int output_formatter_add_field(OutputFormatter *formatter,
+        OutputFieldType type,
+        size_t vallen,
+        char *data,
+        size_t datalen)
+{
+        OutputField *fields;
+
+        fields = realloc_multiply(formatter->fields,
+        sizeof(OutputField),
+        formatter->nfields + 1);
+        if (!fields)
+                return -ENOMEM;
+
+        fields[formatter->nfields].type = type;
+        fields[formatter->nfields].vallen = vallen;
+        fields[formatter->nfields].data = data;
+        fields[formatter->nfields].datalen = datalen;
+        formatter->fields = fields;
+        formatter->nfields++;
+
+        return 0;
+}
+
+static int output_formatter_parse_format(OutputFormatter *formatter, const char *format) {
+        const char *prev = format;
+        char *final_newline;
+        int r;
+
+        do {
+                const char *next;
+                char *data;
+                size_t datalen;
+
+                next = strstr(format, "{");
+
+                if (!next || next != prev) {
+                        datalen = next ? (size_t)(next - prev) : strlen(prev);
+                        data = strndup(prev, datalen);
+
+                        if ((r = output_formatter_add_field(formatter, OUTPUT_FIELD_LITERAL, 0, data, datalen)) < 0) {
+                                free(data);
+                                return r;
+                        }
+                }
+
+                if (next) {
+                        const char *end;
+                        OutputFieldType type;
+                        char *optstr;
+                        uint64_t vallen = 0;
+
+                        end = strchr(next, '}');
+                        if (!end)
+                                return -EINVAL;
+
+                        datalen = (end - (next + 1));
+                        data = strndup(next + 1, datalen);
+
+                        if ((optstr = strchr(data, ':')) != NULL) {
+                                datalen = optstr - data;
+                                *optstr = '\0';
+                                optstr++;
+
+                                if (streq(optstr, "date"))
+                                        type = OUTPUT_FIELD_DATE;
+                                else if (streq(optstr, "date-precise"))
+                                        type = OUTPUT_FIELD_DATE_PRECISE;
+                                else if (streq(optstr, "date-iso"))
+                                        type = OUTPUT_FIELD_DATE_ISO;
+                                else if (streq(optstr, "date-raw"))
+                                        type = OUTPUT_FIELD_DATE_RAW;
+                                else if (safe_atou64(optstr, &vallen) >= 0)
+                                        type = OUTPUT_FIELD_RAW;
+                                else {
+                                        free(data);
+                                        return -EINVAL;
+                                }
+
+                        } else {
+                                if (streq(data, "__REALTIME_TIMESTAMP"))
+                                        type = OUTPUT_FIELD_DATE;
+                                else
+                                        type = OUTPUT_FIELD_RAW;
+                        }
+
+                        if ((r = output_formatter_add_field(formatter, type, vallen, data, datalen)) < 0) {
+                                free(data);
+                                return r;
+                        }
+                        format = end + 1;
+                        prev = end + 1;
+                } else {
+                        format = NULL;
+                }
+        } while (format && *format);
+
+        final_newline = (char *) malloc( 2 * sizeof(char) );
+        strncpy(final_newline, "\n", 2);
+        if ((r = output_formatter_add_field(formatter, OUTPUT_FIELD_LITERAL, 0, final_newline, 2)) < 0){
+                free(final_newline);
+                return r;
+        }
+
+        return 0;
+}
+
+#define DEFAULT_FORMAT "{__REALTIME_TIMESTAMP} {_HOSTNAME} {SYSLOG_IDENTIFIER}[{_PID}]: {MESSAGE}"
+
+int output_formatter_from_mode(OutputMode mode, OutputFormatter **formatter)
+{
+        int r;
+        _cleanup_output_formatter_ OutputFormatter *ret = NULL;
+
+        assert(mode >= 0);
+        assert(mode < _OUTPUT_MODE_MAX);
+        assert(formatter);
+        assert(!*formatter);
+
+        if (!(ret = new(OutputFormatter, 1)))
+                return -ENOMEM;
+
+        ret->mode = mode;
+        if (ret->mode == OUTPUT_FORMAT &&  ((r = output_formatter_parse_format(ret, DEFAULT_FORMAT)) < 0))
+                return r;
+        ret->handler = output_funcs[ret->mode];
+
+        *formatter = ret;
+        ret = NULL;
+        return 0;
+}
+
+int output_formatter_from_string(const char *arg, OutputFormatter **formatter) {
+        int r;
+        _cleanup_output_formatter_ OutputFormatter *ret = NULL;
+
+        assert(arg);
+        assert(formatter);
+        assert(!*formatter);
+
+        if (!(ret = new(OutputFormatter, 1)))
+                return -ENOMEM;
+
+        if (strneq(arg, "format:", 7)) {
+                ret->mode = OUTPUT_FORMAT;
+                if ((r = output_formatter_parse_format(ret, arg + 7)) < 0)
+                        return r;
+        } else {
+                if ((ret->mode = output_mode_from_string(arg)) < 0)
+                        return -EINVAL;
+
+                if (ret->mode == OUTPUT_FORMAT && ((r = output_formatter_parse_format(ret, DEFAULT_FORMAT)) < 0))
+                        return r;
+        }
+        ret->handler = output_funcs[ret->mode];
+
+        *formatter = ret;
+        ret = NULL;
+        return 0;
+}
+
+OutputMode output_formatter_get_mode(OutputFormatter *formatter) {
+        assert(formatter);
+
+        return formatter->mode;
+}
diff --git a/src/shared/logs-show.h b/src/shared/logs-show.h
index 9765a24..9cf61cb 100644
--- a/src/shared/logs-show.h
+++ b/src/shared/logs-show.h
@@ -31,10 +31,12 @@
 #include "time-util.h"
 #include "util.h"
 
+typedef struct _OutputFormatter OutputFormatter;
+
 int output_journal(
                 FILE *f,
                 sd_journal *j,
-                OutputMode mode,
+                OutputFormatter *formatter,
                 unsigned n_columns,
                 OutputFlags flags,
                 bool *ellipsized);
@@ -53,7 +55,7 @@ int add_matches_for_user_unit(
 int show_journal_by_unit(
                 FILE *f,
                 const char *unit,
-                OutputMode mode,
+                OutputFormatter *formatter,
                 unsigned n_columns,
                 usec_t not_before,
                 unsigned how_many,
@@ -71,3 +73,11 @@ void json_escape(
 
 const char* output_mode_to_string(OutputMode m) _const_;
 OutputMode output_mode_from_string(const char *s) _pure_;
+
+int output_formatter_from_string(const char *arg, OutputFormatter **formatter);
+int output_formatter_from_mode(OutputMode mode, OutputFormatter **formatter);
+
+OutputMode output_formatter_get_mode(OutputFormatter *formatter);
+
+void output_formatter_free(OutputFormatter **formatter);
+#define _cleanup_output_formatter_ _cleanup_(output_formatter_free)
diff --git a/src/shared/output-mode.h b/src/shared/output-mode.h
index c5470e7..b565840 100644
--- a/src/shared/output-mode.h
+++ b/src/shared/output-mode.h
@@ -30,6 +30,7 @@ typedef enum OutputMode {
         OUTPUT_JSON_PRETTY,
         OUTPUT_JSON_SSE,
         OUTPUT_CAT,
+        OUTPUT_FORMAT,
         _OUTPUT_MODE_MAX,
         _OUTPUT_MODE_INVALID = -1
 } OutputMode;
diff --git a/src/systemctl/systemctl.c b/src/systemctl/systemctl.c
index c75d12c..deee75f 100644
--- a/src/systemctl/systemctl.c
+++ b/src/systemctl/systemctl.c
@@ -145,7 +145,8 @@ static enum action {
 static BusTransport arg_transport = BUS_TRANSPORT_LOCAL;
 static const char *arg_host = NULL;
 static unsigned arg_lines = 10;
-static OutputMode arg_output = OUTPUT_SHORT;
+static const char *arg_output = "short";
+static OutputFormatter *arg_formatter = NULL;
 static bool arg_plain = false;
 static bool arg_firmware_setup = false;
 static bool arg_now = false;
@@ -3735,7 +3736,7 @@ static void print_status_info(
                 show_journal_by_unit(
                                 stdout,
                                 i->id,
-                                arg_output,
+                                arg_formatter,
                                 0,
                                 i->inactive_exit_timestamp_monotonic,
                                 arg_lines,
@@ -6224,7 +6225,8 @@ static void systemctl_help(void) {
                "  -n --lines=INTEGER  Number of journal entries to show\n"
                "  -o --output=STRING  Change journal output mode (short, short-iso,\n"
                "                              short-precise, short-monotonic, verbose,\n"
-               "                              export, json, json-pretty, json-sse, cat)\n"
+               "                              export, json, json-pretty, json-sse, cat,\n"
+               "                              format:FORMAT-STRING)\n"
                "     --firmware-setup Tell the firmware to show the setup menu on next boot\n"
                "     --plain          Print unit dependencies as a list instead of a tree\n\n"
                "Unit Commands:\n"
@@ -6759,11 +6761,7 @@ static int systemctl_parse_argv(int argc, char *argv[]) {
                         break;
 
                 case 'o':
-                        arg_output = output_mode_from_string(optarg);
-                        if (arg_output < 0) {
-                                log_error("Unknown output '%s'.", optarg);
-                                return -EINVAL;
-                        }
+                        arg_output = optarg;
                         break;
 
                 case 'i':
@@ -7197,6 +7195,7 @@ static int runlevel_parse_argv(int argc, char *argv[]) {
         };
 
         int c;
+        int err;
 
         assert(argc >= 0);
         assert(argv);
@@ -7220,6 +7219,11 @@ static int runlevel_parse_argv(int argc, char *argv[]) {
                 return -EINVAL;
         }
 
+        if ((err = output_formatter_from_string(arg_output, &arg_formatter)) < 0) {
+            log_error("Unknown / malformed output format '%s'.", arg_output);
+            return err;
+        }
+
         return 1;
 }
 
-- 
2.7.4

